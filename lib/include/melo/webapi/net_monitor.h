// Copyright (C) 2024 Alexandre Dilly <dillya@sparod.com>
//
// This program is free software: you can redistribute it and/or modify it under
// the terms of the GNU Affero General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option) any
// later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
// details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

/**
 * @file net_monitor.h
 * @brief Network interface monitoring.
 */

#ifndef MELO_WEBAPI_NET_MONITOR_H_
#define MELO_WEBAPI_NET_MONITOR_H_

#include <atomic>
#include <functional>
#include <thread>

#include <arpa/inet.h>
#include <netinet/in.h>

// External dependencies
#include <fmt/core.h>

struct nlmsghdr;

namespace melo::webapi {

/**
 * Network monitoring class.
 *
 * This class can be used to monitor a Unix network interfaces and detect any
 * changes on them such as the IP address or routes.
 */
class NetMonitor {
 public:
  /**
   * Monitoring mode.
   *
   * Two modes are available in the monitor:
   *  - `THREAD` if the developer prefers to let the class to catch all changes,
   *  - `POLL` if the developer uses an event loop and wants to capture and
   * process events in the same loop as other tasks.
   *
   * When the `POLL` mode is selected, the developer should wait for events with
   * select() or poll() and then call run_once() when the file descriptor
   * returned by get_fd() triggers.
   */
  enum class Mode {
    THREAD,  //!< An internal thread will be started and will capture changes
             //!< asynchronously
    POLL,    //!< The developer should call run_once() periodically to poll for
             //!< changes
  };

  /**
   * Event type.
   *
   * This enumerator list all possible event generated by the network monitor.
   */
  enum class EventType {
    NEW_INTERFACE,  //!< A new interface has been registered
    DEL_INTERFACE,  //!< An interface has been removed
    NEW_ADDRESS,    //!< A new address has been set on one interface
    DEL_ADDRESS,    //!< Address has been deleted on one interface (no more
                    //!< connection)
  };

  /**
   * Interface type.
   *
   * It describes the interface type such as Loopback, Ethernet, Wifi, ...
   */
  enum class InterfaceType {
    UNKNOWN = 0,  //!< Unknown interface type
    LOOPBACK,     //!< Loopback interface type
    ETHERNET,     //!< Ethernet interface type
    WIFI,         //!< WiFi interface type
  };

  /**
   * The interface info structure.
   *
   * This structure contains all the details on the interface which triggered an
   * event (see EventCallback for more details).
   */
  struct InterfaceInfo {
    uint32_t index;         //!< The interface index
    std::string_view name;  //!< The interface name
    InterfaceType type;     //!< The interface type (only valid with
                            //!< `EventType::NEW_INTERFACE`)
    uint8_t mac[6];  //!< The interface address / MAC address (only valid with
                     //!< `EventType::NEW_INTERFACE`)
    struct in_addr
        ipv4;  //!< The IPv4 address (only valid with `EventType::NEW_ADDRESS`)
    struct in6_addr
        ipv6;  //!< The IPv6 address (only valid with `EventType::NEW_ADDRESS`)
  };

  /**
   * Event callback.
   *
   * This function is called every time a change occurs on the network with the
   * event type and related data.
   *
   * @param[in] type The event type which triggered the call
   * @param[in] info The details on the interface which triggered the event
   */
  using EventCallback =
      std::function<void(EventType type, const InterfaceInfo &info)>;

  /**
   * Create a new network monitor.
   *
   * By default, the class will list all interfaces and addresses bound to them
   * at initialization and then it will monitor for any changes as listed by
   * EventType.
   *
   * To disable the initial listing, the `init` parameter should be set to
   * `false`.
   *
   * @param[in] mode The mode to use for monitoring
   * @param[in] cb The event callback to capture all changes on network
   * @param[in] init Set `true` to list all interfaces at initialization
   */
  NetMonitor(Mode mode, const EventCallback &cb, bool init = true);
  NetMonitor(const NetMonitor &) = delete;

  /**
   * Destructor of monitor.
   */
  ~NetMonitor();

  /**
   * Get file descriptor to use for select / poll.
   *
   * The returned file descriptor should be only used for polling: any other
   * usage could lead in errors within the monitoring class.
   *
   * The file descriptor is still managed internally and call to close() is not
   * needed.
   *
   * With poll(), the POLLIN should be used.
   *
   * @return the file descriptor to use.
   */
  inline int get_fd() const { return ntlk_fd_; }

  /**
   * Run internal loop of the monitor.
   *
   * When the polling mode is selected, this function should be called every
   * time that select() or poll() is returning with an event on the file
   * descriptor returned by get_fd().
   *
   */
  bool run_once();

  /**
   * Convert MAC address to string.
   *
   * @param[in] mac The mac address to convert
   * @return a string containing the readable MAC address
   */
  static inline std::string mac_to_string(const uint8_t *mac) {
    return fmt::format("{:02x}:{:02x}:{:02x}:{:02x}:{:02x}:{:02x}", mac[0],
                       mac[1], mac[2], mac[3], mac[4], mac[5]);
  }

  /**
   * Convert IPv4 address to string.
   *
   * @param[in] ip The IPv4 address to convert
   * @return a string containing the readable IP address
   */
  static inline std::string ip_to_string(const struct in_addr &ip) {
    char str[INET_ADDRSTRLEN];
    return inet_ntop(AF_INET, &ip, str, sizeof(str));
  }

  /**
   * Convert IPv6 address to string.
   *
   * @param[in] ip The IPv6 address to convert
   * @return a string containing the readable IP address
   */
  static inline std::string ip_to_string(const struct in6_addr &ip) {
    char str[INET6_ADDRSTRLEN];
    return inet_ntop(AF_INET6, &ip, str, sizeof(str));
  }

 private:
  enum class NextMessage { ADDRESS, NONE };

  const Mode mode_;         //!< The mode for monitoring
  const EventCallback cb_;  //!< The event callback for network changes
  int ntlk_fd_ = -1;        //!< The netlink socket file descriptor

  std::jthread thread_;  //!< Internal thread for event capture

  NextMessage next_msg_ =
      NextMessage::NONE;          //!< Next message to send for initialization
  std::atomic<uint32_t> seq_{1};  //!< The last sequence number for requests

  void parse_link(struct nlmsghdr *nh, bool del);
  void parse_address(struct nlmsghdr *nh, bool del);

  bool get_link();
  bool get_address();

  void thread_entry(std::stop_token stoken);
};

}  // namespace melo::webapi

#endif  // MELO_WEBAPI_NET_MONITOR_H_
